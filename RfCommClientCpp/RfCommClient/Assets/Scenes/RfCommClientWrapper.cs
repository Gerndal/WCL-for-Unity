using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;

using UnityEngine;

// This class contains all Bluetooth Framework error codes (copied from .NET Edition).
// You can find more information about error codes (full description)
// on our site: https://www.btframework.com/errors.htm
public class BluetoothErrors
{
    public const Int32 WCL_E_SUCCESS = 0x00000000;

    public const Int32 WCL_E_BASE = 0x00010000;
    public const Int32 WCL_E_INVALID_ARGUMENT = WCL_E_BASE + 0x0000;
    public const Int32 WCL_E_OUT_OF_MEMORY = WCL_E_BASE + 0x0001;
    public const Int32 WCL_E_THREAD_RUNNING = WCL_E_BASE + 0x0002;
    public const Int32 WCL_E_UNABLE_CREATE_THREAD_INIT_EVENT = WCL_E_BASE + 0x0003;
    public const Int32 WCL_E_UNABLE_CREATE_THREAD = WCL_E_BASE + 0x0004;
    public const Int32 WCL_E_THREAD_NOT_RUNNING = WCL_E_BASE + 0x0005;
    public const Int32 WCL_E_THREAD_SIGNAL_FAILED = WCL_E_BASE + 0x0006;
    public const Int32 WCL_E_THREAD_MESSAGE_REGISTRATION_FAILED = WCL_E_BASE + 0x0007;
    public const Int32 WCL_E_THREAD_WINDOW_CREATION_FAILED = WCL_E_BASE + 0x0008;
    public const Int32 WCL_E_THREAD_INITIALIZATION_FAILED = WCL_E_BASE + 0x0009;

    public const Int32 WCL_E_MR_BASE = WCL_E_BASE + 0x1000;
    public const Int32 WCL_E_MR_CLOSED = WCL_E_MR_BASE + 0x0000;
    public const Int32 WCL_E_MR_OPENED = WCL_E_MR_BASE + 0x0001;
    public const Int32 WCL_E_MR_NOT_OPENED = WCL_E_MR_BASE + 0x0002;
    public const Int32 WCL_E_MR_UNABLE_SYNCHRONIZE = WCL_E_MR_BASE + 0x0003;
    public const Int32 WCL_E_MR_UNABLE_REGISTER_SYNC_OBJ = WCL_E_MR_BASE + 0x0004;
    public const Int32 WCL_E_MR_UNABLE_CREATE_SYNC_OBJ = WCL_E_MR_BASE + 0x0005;
    public const Int32 WCL_E_MR_SYNC_OBJ_NOT_CREATED = WCL_E_MR_BASE + 0x0006;

    public const Int32 WCL_E_MB_BASE = WCL_E_BASE + 0x2000;
    public const Int32 WCL_E_MB_RECEIVER_ALREADY_SUBSCRIBED = WCL_E_MB_BASE + 0x0000;
    public const Int32 WCL_E_MB_RECEIVER_NOT_SUBSCRIBED = WCL_E_MB_BASE + 0x0001;
    public const Int32 WCL_E_MB_CAN_NOT_INIT_HW_THREAD = WCL_E_MB_BASE + 0x0002;
    public const Int32 WCL_E_MB_CAN_NOT_START_HW_THREAD = WCL_E_MB_BASE + 0x0003;
    public const Int32 WCL_E_MB_UNABLE_CREATE_HW_OBJ = WCL_E_MB_BASE + 0x0004;
    public const Int32 WCL_E_MB_UNABLE_REGISTER_HW_NOTIFY = WCL_E_MB_BASE + 0x0005;
    public const Int32 WCL_E_MB_UNABLE_CREATE_MUTEX = WCL_E_MB_BASE + 0x0006;
    public const Int32 WCL_E_MB_NOT_CREATED = WCL_E_MB_BASE + 0x0007;
    public const Int32 WCL_E_MB_REF_COUNT_ERROR = WCL_E_MB_BASE + 0x0008;
    public const Int32 WCL_E_MB_RUNNING = WCL_E_MB_BASE + 0x0009;

    public const Int32 WCL_E_WINRT_BASE = WCL_E_BASE + 0x3000;
    public const Int32 WCL_E_WINRT_UNABLE_CREATE_MUTEX = WCL_E_WINRT_BASE + 0x0000;
    public const Int32 WCL_E_WINRT_UNABLE_LOAD_CORE_DLL = WCL_E_WINRT_BASE + 0x0001;
    public const Int32 WCL_E_WINRT_UNABLE_LOAD_STRING_DLL = WCL_E_WINRT_BASE + 0x0002;
    public const Int32 WCL_E_WINRT_INIT_FAILED = WCL_E_WINRT_BASE + 0x0003;
    public const Int32 WCL_E_WINRT_UNABLE_CREATE_STRING = WCL_E_WINRT_BASE + 0x0004;
    public const Int32 WCL_E_WINRT_UNABLE_ACTIVATE_INSTANCE = WCL_E_WINRT_BASE + 0x0005;
    public const Int32 WCL_E_WINRT_UNABLE_CREATE_INTERFACE = WCL_E_WINRT_BASE + 0x0006;
    public const Int32 WCL_E_WINRT_ASYNC_OPERATION_FAILED = WCL_E_WINRT_BASE + 0x0007;
    public const Int32 WCL_E_WINRT_ASYNC_OPERATION_CANCELLED = WCL_E_WINRT_BASE + 0x0008;
    public const Int32 WCL_E_WINRT_ASYNC_OPERATION_ERROR = WCL_E_WINRT_BASE + 0x0009;
    public const Int32 WCL_E_WINRT_DETACH_BUFFER_FAILED = WCL_E_WINRT_BASE + 0x000A;

    public const Int32 WCL_E_CONNECTION_BASE = 0x00030000;
    public const Int32 WCL_E_CONNECTION_ACTIVE = WCL_E_CONNECTION_BASE + 0x0000;
    public const Int32 WCL_E_CONNECTION_NOT_ACTIVE = WCL_E_CONNECTION_BASE + 0x0001;
    public const Int32 WCL_E_CONNECTION_UNABLE_CREATE_TERMINATE_EVENT = WCL_E_CONNECTION_BASE + 0x0002;
    public const Int32 WCL_E_CONNECTION_UNABLE_CREATE_CONNECTION_COMPLETE_EVENT = WCL_E_CONNECTION_BASE + 0x0003;
    public const Int32 WCL_E_CONNECTION_UNABLE_START_COMMUNICATION = WCL_E_CONNECTION_BASE + 0x0004;
    public const Int32 WCL_E_CONNECTION_TERMINATED = WCL_E_CONNECTION_BASE + 0x0005;
    public const Int32 WCL_E_CONNECTION_TERMINATED_BY_USER = WCL_E_CONNECTION_BASE + 0x0006;
    public const Int32 WCL_E_CONNECTION_UNABLE_CREATE_INIT_EVENT = WCL_E_CONNECTION_BASE + 0x0007;
    public const Int32 WCL_E_CONNECTION_CLOSED = WCL_E_CONNECTION_BASE + 0x0008;
    public const Int32 WCL_E_CONNECTION_UNEXPECTED = WCL_E_CONNECTION_BASE + 0x0009;
    public const Int32 WCL_E_CONNECTION_UNABLE_CREATE_OR_INIT_CLIENT = WCL_E_CONNECTION_BASE + 0x000A;
    public const Int32 WCL_E_CONNECTION_UNABLE_FIND_CLIENT_CLASS = WCL_E_CONNECTION_BASE + 0x000B;

    public const Int32 WCL_E_OBEX_BASE = WCL_E_CONNECTION_BASE + 0x1000;
    public const Int32 WCL_E_OBEX_NOT_CONNECTED = WCL_E_OBEX_BASE + 0x0000;
    public const Int32 WCL_E_OBEX_CONNECTED = WCL_E_OBEX_BASE + 0x0001;
    public const Int32 WCL_E_OBEX_OPERATION_IN_PROGRESS = WCL_E_OBEX_BASE + 0x0002;
    public const Int32 WCL_E_OBEX_CONTINUE = WCL_E_OBEX_BASE + 0x0003;
    public const Int32 WCL_E_OBEX_CREATED = WCL_E_OBEX_BASE + 0x0004;
    public const Int32 WCL_E_OBEX_ACCEPTED = WCL_E_OBEX_BASE + 0x0005;
    public const Int32 WCL_E_OBEX_NON_AUTHORITATIVE = WCL_E_OBEX_BASE + 0x0006;
    public const Int32 WCL_E_OBEX_NO_CONTENT = WCL_E_OBEX_BASE + 0x0007;
    public const Int32 WCL_E_OBEX_RESET_CONTENT = WCL_E_OBEX_BASE + 0x0008;
    public const Int32 WCL_E_OBEX_PARTIAL_CONTENT = WCL_E_OBEX_BASE + 0x0009;
    public const Int32 WCL_E_OBEX_MULTIPLE_CHOICES = WCL_E_OBEX_BASE + 0x000A;
    public const Int32 WCL_E_OBEX_MOVED_PERMANENTLY = WCL_E_OBEX_BASE + 0x000B;
    public const Int32 WCL_E_OBEX_MOVED_TEMPORARY = WCL_E_OBEX_BASE + 0x000C;
    public const Int32 WCL_E_OBEX_SEE_OTHER = WCL_E_OBEX_BASE + 0x000D;
    public const Int32 WCL_E_OBEX_NOT_MODIFIED = WCL_E_OBEX_BASE + 0x000E;
    public const Int32 WCL_E_OBEX_USE_PROXY = WCL_E_OBEX_BASE + 0x000F;
    public const Int32 WCL_E_OBEX_BAD_REQUEST = WCL_E_OBEX_BASE + 0x0010;
    public const Int32 WCL_E_OBEX_UNAUTHORIZED = WCL_E_OBEX_BASE + 0x0011;
    public const Int32 WCL_E_OBEX_PAYMENT_REQUIRED = WCL_E_OBEX_BASE + 0x0012;
    public const Int32 WCL_E_OBEX_FORBIDDEN = WCL_E_OBEX_BASE + 0x0013;
    public const Int32 WCL_E_OBEX_NOT_FOUND = WCL_E_OBEX_BASE + 0x0014;
    public const Int32 WCL_E_OBEX_METHOD_NOT_ALLOWED = WCL_E_OBEX_BASE + 0x0015;
    public const Int32 WCL_E_OBEX_NOT_ACCEPTABLE = WCL_E_OBEX_BASE + 0x0016;
    public const Int32 WCL_E_OBEX_PROXY_AUTH_REQUIRED = WCL_E_OBEX_BASE + 0x0017;
    public const Int32 WCL_E_OBEX_REQUEST_TIMEOUT = WCL_E_OBEX_BASE + 0x0018;
    public const Int32 WCL_E_OBEX_CONFLICT = WCL_E_OBEX_BASE + 0x0019;
    public const Int32 WCL_E_OBEX_GONE = WCL_E_OBEX_BASE + 0x001A;
    public const Int32 WCL_E_OBEX_LENGTH_REQUIRED = WCL_E_OBEX_BASE + 0x001B;
    public const Int32 WCL_E_OBEX_PRECONDITION_FAILED = WCL_E_OBEX_BASE + 0x001C;
    public const Int32 WCL_E_OBEX_REQUEST_TOO_LARGE = WCL_E_OBEX_BASE + 0x001D;
    public const Int32 WCL_E_OBEX_URL_TOO_LARGE = WCL_E_OBEX_BASE + 0x001E;
    public const Int32 WCL_E_OBEX_UNSUPPORTED_MEDIA_TYPE = WCL_E_OBEX_BASE + 0x001F;
    public const Int32 WCL_E_OBEX_INTERNAL = WCL_E_OBEX_BASE + 0x0020;
    public const Int32 WCL_E_OBEX_NOT_IMPLEMENTED = WCL_E_OBEX_BASE + 0x0021;
    public const Int32 WCL_E_OBEX_BAD_GATEWAY = WCL_E_OBEX_BASE + 0x0022;
    public const Int32 WCL_E_OBEX_SERVICE_UNAVAILABLE = WCL_E_OBEX_BASE + 0x0023;
    public const Int32 WCL_E_OBEX_GATEWAY_TIMEOUT = WCL_E_OBEX_BASE + 0x0024;
    public const Int32 WCL_E_OBEX_HTTP_VERSION_NOT_SUPPORTED = WCL_E_OBEX_BASE + 0x0025;
    public const Int32 WCL_E_OBEX_DATABASE_FULL = WCL_E_OBEX_BASE + 0x0026;
    public const Int32 WCL_E_OBEX_DATABASE_LOCKED = WCL_E_OBEX_BASE + 0x0027;
    public const Int32 WCL_E_OBEX_OPERATION_TERMINATED_BY_DISCONNECT = WCL_E_OBEX_BASE + 0x0028;
    public const Int32 WCL_E_OBEX_OPERATION_TERMINATED_BY_USER = WCL_E_OBEX_BASE + 0x0029;
    public const Int32 WCL_E_OBEX_INVALID_OPERATION_SEQUENCE = WCL_E_OBEX_BASE + 0x002A;
    public const Int32 WCL_E_OBEX_DISCONNECTED = WCL_E_OBEX_BASE + 0x002B;
    public const Int32 WCL_E_OBEX_UNEXPECTED = WCL_E_OBEX_BASE + 0x002C;
    public const Int32 WCL_E_OBEX_CREATE_CONNECTION_ID_MUTEX_FAILED = WCL_E_OBEX_BASE + 0x002D;
    public const Int32 WCL_E_OBEX_MAX_CONNECTION_ID = WCL_E_OBEX_BASE + 0x002E;
    public const Int32 WCL_E_OBEX_INVALID_STATE = WCL_E_OBEX_BASE + 0x002F;

    public const Int32 WCL_E_BLUETOOTH_BASE = 0x00050000;
    public const Int32 WCL_E_BLUETOOTH_MANAGER_CLOSED = WCL_E_BLUETOOTH_BASE + 0x0000;
    public const Int32 WCL_E_BLUETOOTH_MANAGER_OPENED = WCL_E_BLUETOOTH_BASE + 0x0001;
    public const Int32 WCL_E_BLUETOOTH_MANAGER_OPEN_FAILED = WCL_E_BLUETOOTH_BASE + 0x0002;
    public const Int32 WCL_E_BLUETOOTH_MANAGER_EXISTS = WCL_E_BLUETOOTH_BASE + 0x0003;
    public const Int32 WCL_E_BLUETOOTH_DRIVER_NOT_AVAILABLE = WCL_E_BLUETOOTH_BASE + 0x0004;
    public const Int32 WCL_E_BLUETOOTH_HARDWARE_NOT_AVAILABLE = WCL_E_BLUETOOTH_BASE + 0x0005;
    public const Int32 WCL_E_BLUETOOTH_API_NOT_LOADED = WCL_E_BLUETOOTH_BASE + 0x0006;
    public const Int32 WCL_E_BLUETOOTH_API_INITIALIZATION_FAILED = WCL_E_BLUETOOTH_BASE + 0x0007;
    public const Int32 WCL_E_BLUETOOTH_API_NOT_FOUND = WCL_E_BLUETOOTH_BASE + 0x0008;
    public const Int32 WCL_E_BLUETOOTH_API_NOT_INITIALIZED = WCL_E_BLUETOOTH_BASE + 0x0009;
    public const Int32 WCL_E_BLUETOOTH_WRONG_DRIVER_VERSION = WCL_E_BLUETOOTH_BASE + 0x000A;
    public const Int32 WCL_E_BLUETOOTH_RADIO_OPENED = WCL_E_BLUETOOTH_BASE + 0x000B;
    public const Int32 WCL_E_BLUETOOTH_RADIO_CLOSED = WCL_E_BLUETOOTH_BASE + 0x000C;
    public const Int32 WCL_E_BLUETOOTH_RADIO_REMOVED = WCL_E_BLUETOOTH_BASE + 0x000D;
    public const Int32 WCL_E_BLUETOOTH_RADIO_INSTANCE_INIT_FAILED = WCL_E_BLUETOOTH_BASE + 0x000E;
    public const Int32 WCL_E_BLUETOOTH_RADIO_INSTANCE_EXISTS = WCL_E_BLUETOOTH_BASE + 0x000F;
    public const Int32 WCL_E_BLUETOOTH_RADIO_UNAVAILABLE = WCL_E_BLUETOOTH_BASE + 0x0010;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CHANGE_CONNECTABLE_STATE = WCL_E_BLUETOOTH_BASE + 0x0011;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CHANGE_DISCOVERABLE_STATE = WCL_E_BLUETOOTH_BASE + 0x0012;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CHANGE_NAME = WCL_E_BLUETOOTH_BASE + 0x0013;
    public const Int32 WCL_E_BLUETOOTH_FEATURE_NOT_SUPPORTED = WCL_E_BLUETOOTH_BASE + 0x0014;
    public const Int32 WCL_E_BLUETOOTH_UNEXPECTED = WCL_E_BLUETOOTH_BASE + 0x0015;
    public const Int32 WCL_E_BLUETOOTH_LINK_UNEXPECTED = WCL_E_BLUETOOTH_BASE + 0x0016;
    public const Int32 WCL_E_BLUETOOTH_OPERATION_FAILED = WCL_E_BLUETOOTH_BASE + 0x0017;
    public const Int32 WCL_E_BLUETOOTH_OPERATION_CONFLICT = WCL_E_BLUETOOTH_BASE + 0x0018;
    public const Int32 WCL_E_BLUETOOTH_NO_MORE_CONNECTION_ALLOWED = WCL_E_BLUETOOTH_BASE + 0x0019;
    public const Int32 WCL_E_BLUETOOTH_OBJECT_EXISTS = WCL_E_BLUETOOTH_BASE + 0x001A;
    public const Int32 WCL_E_BLUETOOTH_OBJECT_IN_USE = WCL_E_BLUETOOTH_BASE + 0x001B;
    public const Int32 WCL_E_BLUETOOTH_DISCOVERING_RUNNING = WCL_E_BLUETOOTH_BASE + 0x001C;
    public const Int32 WCL_E_BLUETOOTH_DISCOVERING_NOT_RUNNING = WCL_E_BLUETOOTH_BASE + 0x001D;
    public const Int32 WCL_E_BLUETOOTH_DISCOVERING_TERMINATED = WCL_E_BLUETOOTH_BASE + 0x001E;
    public const Int32 WCL_E_BLUETOOTH_CANCELLED_BY_USER = WCL_E_BLUETOOTH_BASE + 0x001F;
    public const Int32 WCL_E_BLUETOOTH_TIMEOUT = WCL_E_BLUETOOTH_BASE + 0x0020;
    public const Int32 WCL_E_BLUETOOTH_CONNECTION_TERMINATED_BY_USER = WCL_E_BLUETOOTH_BASE + 0x0021;
    public const Int32 WCL_E_BLUETOOTH_PENDING = WCL_E_BLUETOOTH_BASE + 0x0022;
    public const Int32 WCL_E_BLUETOOTH_CONNECTION_FAILED = WCL_E_BLUETOOTH_BASE + 0x0023;
    public const Int32 WCL_E_BLUETOOTH_DEVICE_NOT_FOUND = WCL_E_BLUETOOTH_BASE + 0x0024;
    public const Int32 WCL_E_BLUETOOTH_PAIRING = WCL_E_BLUETOOTH_BASE + 0x0025;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_START_PAIRING = WCL_E_BLUETOOTH_BASE + 0x0026;
    public const Int32 WCL_E_BLUETOOTH_ALREADY_PAIRED = WCL_E_BLUETOOTH_BASE + 0x0027;
    public const Int32 WCL_E_BLUETOOTH_DEVICE_NOT_PAIRED = WCL_E_BLUETOOTH_BASE + 0x0028;
    public const Int32 WCL_E_BLUETOOTH_ACCESS_DENIED = WCL_E_BLUETOOTH_BASE + 0x0029;
    public const Int32 WCL_E_BLUETOOTH_AUTHENTICATION_FAILED = WCL_E_BLUETOOTH_BASE + 0x002A;
    public const Int32 WCL_E_BLUETOOTH_REJECTED = WCL_E_BLUETOOTH_BASE + 0x002B;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_GET_READ_BUFFER = WCL_E_BLUETOOTH_BASE + 0x002C;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_GET_WRITE_BUFFER = WCL_E_BLUETOOTH_BASE + 0x002D;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_SET_READ_BUFFER = WCL_E_BLUETOOTH_BASE + 0x002E;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_SET_WRITE_BUFFER = WCL_E_BLUETOOTH_BASE + 0x002F;
    public const Int32 WCL_E_BLUETOOTH_CLIENT_CONNECTED = WCL_E_BLUETOOTH_BASE + 0x0030;
    public const Int32 WCL_E_BLUETOOTH_CLIENT_NOT_CONNECTED = WCL_E_BLUETOOTH_BASE + 0x0031;
    public const Int32 WCL_E_BLUETOOTH_L2CAP_DISCONNECTED = WCL_E_BLUETOOTH_BASE + 0x0032;
    public const Int32 WCL_E_BLUETOOTH_INVALID_DEVICE_TYPE = WCL_E_BLUETOOTH_BASE + 0x0033;
    public const Int32 WCL_E_BLUETOOTH_CHANNEL_IN_USE = WCL_E_BLUETOOTH_BASE + 0x0034;
    public const Int32 WCL_E_BLUETOOTH_SERVICE_NOT_VALID = WCL_E_BLUETOOTH_BASE + 0x0035;
    public const Int32 WCL_E_BLUETOOTH_SERVICE_NOT_FOUND = WCL_E_BLUETOOTH_BASE + 0x0036;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_SOCKET = WCL_E_BLUETOOTH_BASE + 0x0037;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_SET_CLIENT_SECURITY = WCL_E_BLUETOOTH_BASE + 0x0038;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_EVENT = WCL_E_BLUETOOTH_BASE + 0x0039;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_SET_EVENT = WCL_E_BLUETOOTH_BASE + 0x003A;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_LOCK_CONNECT_MUTEX = WCL_E_BLUETOOTH_BASE + 0x003B;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_INIT_OVERLAPPED_OPERATION = WCL_E_BLUETOOTH_BASE + 0x003C;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_DISCONNECT_EVENT = WCL_E_BLUETOOTH_BASE + 0x003D;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_CONNECT_EVENT = WCL_E_BLUETOOTH_BASE + 0x003E;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_LOCK_SDP_MUTEX = WCL_E_BLUETOOTH_BASE + 0x003F;
    public const Int32 WCL_E_BLUETOOTH_RFCOMM_SESSION_DISCONNECTED = WCL_E_BLUETOOTH_BASE + 0x0040;
    public const Int32 WCL_E_BLUETOOTH_RFCOMM_DOWN = WCL_E_BLUETOOTH_BASE + 0x0041;
    public const Int32 WCL_E_BLUETOOTH_RFCOMM_DISCONNECTED = WCL_E_BLUETOOTH_BASE + 0x0042;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_TO_RESOLVE_ADDRESS = WCL_E_BLUETOOTH_BASE + 0x0043;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_ADD_ADP_RECORD = WCL_E_BLUETOOTH_BASE + 0x0044;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_SET_SERVER_SECURITY = WCL_E_BLUETOOTH_BASE + 0x0045;
    public const Int32 WCL_E_BLUETOOTH_LOCAL_SERVICE_ACTIVE = WCL_E_BLUETOOTH_BASE + 0x0046;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_SERVER = WCL_E_BLUETOOTH_BASE + 0x0047;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_ENUMERATE_LOCAL_SERVICES = WCL_E_BLUETOOTH_BASE + 0x0048;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_STOP_LOCAL_SERVER = WCL_E_BLUETOOTH_BASE + 0x0049;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_TO_UPDATE_LOCAL_SERVER = WCL_E_BLUETOOTH_BASE + 0x004A;
    public const Int32 WCL_E_BLUETOOTH_SETUP_COM_FAILED = WCL_E_BLUETOOTH_BASE + 0x004B;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_OPEN_CLIENT_COM = WCL_E_BLUETOOTH_BASE + 0x004C;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_OPEN_SERVER_COM = WCL_E_BLUETOOTH_BASE + 0x004D;
    public const Int32 WCL_E_BLUETOOTH_WRITE_FAILED = WCL_E_BLUETOOTH_BASE + 0x004E;
    public const Int32 WCL_E_BLUETOOTH_READ_FAILED = WCL_E_BLUETOOTH_BASE + 0x004F;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_WND = WCL_E_BLUETOOTH_BASE + 0x0050;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_REGISTER_MESSAGE = WCL_E_BLUETOOTH_BASE + 0x0051;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_SYNC_EVENT = WCL_E_BLUETOOTH_BASE + 0x0052;
    public const Int32 WCL_E_BLUETOOTH_SDP_TRANSACTION = WCL_E_BLUETOOTH_BASE + 0x0053;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_START_SDP_THREAD = WCL_E_BLUETOOTH_BASE + 0x0054;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_START_CONNECT_THREAD = WCL_E_BLUETOOTH_BASE + 0x0055;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_START_LISTEN_THREAD = WCL_E_BLUETOOTH_BASE + 0x0056;
    public const Int32 WCL_E_BLUETOOTH_DISCOVERING_FAILED = WCL_E_BLUETOOTH_BASE + 0x0057;
    public const Int32 WCL_E_BLUETOOTH_READ_REMOTE_NAME_FAILED = WCL_E_BLUETOOTH_BASE + 0x0058;
    public const Int32 WCL_E_BLUETOOTH_DESTROY_COM_FAILED = WCL_E_BLUETOOTH_BASE + 0x0059;
    public const Int32 WCL_E_BLUETOOTH_CONNECT_COM_FAILED = WCL_E_BLUETOOTH_BASE + 0x005A;
    public const Int32 WCL_E_BLUETOOTH_DISCONNECT_COM_FAILED = WCL_E_BLUETOOTH_BASE + 0x005B;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_TO_SWITCH_ON_OR_OFF = WCL_E_BLUETOOTH_BASE + 0x005C;
    public const Int32 WCL_E_BLUETOOTH_CANNOT_ASSIGN_PSM = WCL_E_BLUETOOTH_BASE + 0x005D;
    public const Int32 WCL_E_BLUETOOTH_GETLOCALINFO_FAILED = WCL_E_BLUETOOTH_BASE + 0x005E;
    public const Int32 WCL_E_BLUETOOTH_DISCONNECT_SDP_FAILED = WCL_E_BLUETOOTH_BASE + 0x005F;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_REGISTER_COM_NOTIFICATION = WCL_E_BLUETOOTH_BASE + 0x0060;
    public const Int32 WCL_E_BLUETOOTH_SETLOCALINFO_FAILED = WCL_E_BLUETOOTH_BASE + 0x0061;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_TO_GET_CONNECTED_DEVICES = WCL_E_BLUETOOTH_BASE + 0x0062;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CONNECT = WCL_E_BLUETOOTH_BASE + 0x0063;
    public const Int32 WCL_E_BLUETOOTH_CONNECT_PSM = WCL_E_BLUETOOTH_BASE + 0x0064;
    public const Int32 WCL_E_BLUETOOTH_SDP_PARSE_ERROR = WCL_E_BLUETOOTH_BASE + 0x0065;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_READ_RSSI = WCL_E_BLUETOOTH_BASE + 0x0066;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CHANGE_PAIRING_MODE = WCL_E_BLUETOOTH_BASE + 0x0067;
    public const Int32 WCL_E_BLUETOOTH_SDP_ERROR = WCL_E_BLUETOOTH_BASE + 0x0068;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_START_THREAD = WCL_E_BLUETOOTH_BASE + 0x0069;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CREATE_INIT_EVENT = WCL_E_BLUETOOTH_BASE + 0x006A;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_START_INIT_THREAD = WCL_E_BLUETOOTH_BASE + 0x006B;
    public const Int32 WCL_E_BLUETOOTH_VCOM_NOT_FOUND = WCL_E_BLUETOOTH_BASE + 0x006C;
    public const Int32 WCL_E_BLUETOOTH_VCOM_EXISTS = WCL_E_BLUETOOTH_BASE + 0x006D;
    public const Int32 WCL_E_BLUETOOTH_CREATE_DEVICE_STATICS_FAILED = WCL_E_BLUETOOTH_BASE + 0x006E;
    public const Int32 WCL_E_BLUETOOTH_START_ASYNC_OPERATION_FAILED = WCL_E_BLUETOOTH_BASE + 0x006F;
    public const Int32 WCL_E_BLUETOOTH_SET_ASYNC_OPERATION_EVENT_HANDLER_FAILED = WCL_E_BLUETOOTH_BASE + 0x0070;
    public const Int32 WCL_E_BLUETOOTH_CREATE_DEVICE_FAILED = WCL_E_BLUETOOTH_BASE + 0x0071;
    public const Int32 WCL_E_BLUETOOTH_GET_ASYNC_OPERATION_RESULT_FAILED = WCL_E_BLUETOOTH_BASE + 0x0072;
    public const Int32 WCL_E_BLUETOOTH_GET_DEVICE_ID_FAILED = WCL_E_BLUETOOTH_BASE + 0x0073;
    public const Int32 WCL_E_BLUETOOTH_GET_DEVICE_PROPERTIES_FAILED = WCL_E_BLUETOOTH_BASE + 0x0074;
    public const Int32 WCL_E_BLUETOOTH_START_RSSI_THREAD_FAILED = WCL_E_BLUETOOTH_BASE + 0x0075;
    public const Int32 WCL_E_BLUETOOTH_GET_RSSI_READING_RESULT_FAILED = WCL_E_BLUETOOTH_BASE + 0x0076;
    public const Int32 WCL_E_BLUETOOTH_INCOMPATIBLE_OS_BITS = WCL_E_BLUETOOTH_BASE + 0x0077;
    public const Int32 WCL_E_BLUETOOTH_GET_RADIOS_LIST_FAILED = WCL_E_BLUETOOTH_BASE + 0x0078;
    public const Int32 WCL_E_BLUETOOTH_GET_RADIOS_COUNT_FAILED = WCL_E_BLUETOOTH_BASE + 0x0079;
    public const Int32 WCL_E_BLUETOOTH_GET_BLUETOOTH_RADIO_FAILED = WCL_E_BLUETOOTH_BASE + 0x007A;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_CHANGE_RADIO_STATE = WCL_E_BLUETOOTH_BASE + 0x007B;
    public const Int32 WCL_E_BLUETOOTH_START_GET_DEV_TYPE_THREAD_FAILED = WCL_E_BLUETOOTH_BASE + 0x007C;
    public const Int32 WCL_E_BLUETOOTH_GET_DEV_TYPE_THREAD_GET_RESULT_FAILED = WCL_E_BLUETOOTH_BASE + 0x007D;
    public const Int32 WCL_E_BLUETOOTH_START_GET_DEV_NAME_THREAD_FAILED = WCL_E_BLUETOOTH_BASE + 0x007E;
    public const Int32 WCL_E_BLUETOOTH_GET_DEV_NAME_THREAD_GET_RESULT_FAILED = WCL_E_BLUETOOTH_BASE + 0x007F;
    public const Int32 WCL_E_BLUETOOTH_NO_SYSTEM_RESOURCES = WCL_E_BLUETOOTH_BASE + 0x0080;
    public const Int32 WCL_E_BLUETOOTH_CREATE_REG_CHANGE_TERMINATION_EVENT_FAILED = WCL_E_BLUETOOTH_BASE + 0x0081;
    public const Int32 WCL_E_BLUETOOTH_CREATE_REG_CHANGE_RESULT_EVENT_FAILED = WCL_E_BLUETOOTH_BASE + 0x0082;
    public const Int32 WCL_E_BLUETOOTH_START_REG_CHANGE_THREAD_FAILED = WCL_E_BLUETOOTH_BASE + 0x0083;
    public const Int32 WCL_E_BLUETOOTH_REGISTER_AUTHENTICATION_CALLBACK_FAILED = WCL_E_BLUETOOTH_BASE + 0x0084;
    public const Int32 WCL_E_BLUETOOTH_FAILED_TO_OPEN_AUTH_AGENT_REG_KEY = WCL_E_BLUETOOTH_BASE + 0x0085;
    public const Int32 WCL_E_BLUETOOTH_CREATE_REG_CHANGES_NOTIFICATION_EVENT_FAILED = WCL_E_BLUETOOTH_BASE + 0x0086;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_SET_REGISTRY_CHANGES_NOTIFICATIONS = WCL_E_BLUETOOTH_BASE + 0x0087;
    public const Int32 WCL_E_BLUETOOTH_UNABLE_TO_DISABLE_AUTHENTICATION_AGENT = WCL_E_BLUETOOTH_BASE + 0x0088;
    public const Int32 WCL_E_BLUETOOTH_PAIRED_BY_OTHER = WCL_E_BLUETOOTH_BASE + 0x0089;
    public const Int32 WCL_E_BLUETOOTH_DEVICE_ALREADY_INSTALLED = WCL_E_BLUETOOTH_BASE + 0x008A;
    public const Int32 WCL_E_BLUETOOTH_DEVICE_NOT_INSTALLED = WCL_E_BLUETOOTH_BASE + 0x008B;
    public const Int32 WCL_E_BLUETOOTH_DEVICE_NOT_CONNECTED = WCL_E_BLUETOOTH_BASE + 0x008C;
    public const Int32 WCL_E_BLUETOOTH_ENUM_CONNECTION_FAILED = WCL_E_BLUETOOTH_BASE + 0x008D;
    public const Int32 WCL_E_BLUETOOTH_WAIT_FAILED = WCL_E_BLUETOOTH_BASE + 0x008E;

    public const Int32 WCL_E_BLUETOOTH_LE_BASE = WCL_E_BLUETOOTH_BASE + 0x1000;
    public const Int32 WCL_E_BLUETOOTH_LE_INVALID_HANDLE = WCL_E_BLUETOOTH_LE_BASE + 0x0000;
    public const Int32 WCL_E_BLUETOOTH_LE_READ_NOT_PERMITTED = WCL_E_BLUETOOTH_LE_BASE + 0x0001;
    public const Int32 WCL_E_BLUETOOTH_LE_WRITE_NOT_PERMITTED = WCL_E_BLUETOOTH_LE_BASE + 0x0002;
    public const Int32 WCL_E_BLUETOOTH_LE_INVALID_PDU = WCL_E_BLUETOOTH_LE_BASE + 0x0003;
    public const Int32 WCL_E_BLUETOOTH_LE_INSUFFICIENT_AUTHENTICATION = WCL_E_BLUETOOTH_LE_BASE + 0x0004;
    public const Int32 WCL_E_BLUETOOTH_LE_REQUEST_NOT_SUPPORTED = WCL_E_BLUETOOTH_LE_BASE + 0x0005;
    public const Int32 WCL_E_BLUETOOTH_LE_INVALID_OFFSET = WCL_E_BLUETOOTH_LE_BASE + 0x0006;
    public const Int32 WCL_E_BLUETOOTH_LE_INSUFFICIENT_AUTHORIZATION = WCL_E_BLUETOOTH_LE_BASE + 0x0007;
    public const Int32 WCL_E_BLUETOOTH_LE_PREPARE_QUEUE_FULL = WCL_E_BLUETOOTH_LE_BASE + 0x0008;
    public const Int32 WCL_E_BLUETOOTH_LE_ATTRIBUTE_NOT_FOUND = WCL_E_BLUETOOTH_LE_BASE + 0x0009;
    public const Int32 WCL_E_BLUETOOTH_LE_ATTRIBUTE_NOT_LONG = WCL_E_BLUETOOTH_LE_BASE + 0x000A;
    public const Int32 WCL_E_BLUETOOTH_LE_INSUFFICIENT_ENCRYPTION_KEYSIZE = WCL_E_BLUETOOTH_LE_BASE + 0x000B;
    public const Int32 WCL_E_BLUETOOTH_LE_INVALID_ATTRIBUTE_VALUE_LENGTH = WCL_E_BLUETOOTH_LE_BASE + 0x000C;
    public const Int32 WCL_E_BLUETOOTH_LE_INSUFFICIENT_ENCRYPTION = WCL_E_BLUETOOTH_LE_BASE + 0x000D;
    public const Int32 WCL_E_BLUETOOTH_LE_UNSUPPORTED_GROUP_TYPE = WCL_E_BLUETOOTH_LE_BASE + 0x000E;
    public const Int32 WCL_E_BLUETOOTH_LE_INSUFFICIENT_RESOURCES = WCL_E_BLUETOOTH_LE_BASE + 0x000F;
    public const Int32 WCL_E_BLUETOOTH_LE_SMP_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0010;
    public const Int32 WCL_E_BLUETOOTH_LE_TASK_CANCEL = WCL_E_BLUETOOTH_LE_BASE + 0x0011;
    public const Int32 WCL_E_BLUETOOTH_LE_CONNECT_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0012;
    public const Int32 WCL_E_BLUETOOTH_LE_TIMEOUT = WCL_E_BLUETOOTH_LE_BASE + 0x0013;
    public const Int32 WCL_E_BLUETOOTH_LE_WRONG_CONFIGURATION = WCL_E_BLUETOOTH_LE_BASE + 0x0014;
    public const Int32 WCL_E_BLUETOOTH_LE_PROCEDURE_IN_PROGRESS = WCL_E_BLUETOOTH_LE_BASE + 0x0015;
    public const Int32 WCL_E_BLUETOOTH_LE_OUT_OF_RANGE = WCL_E_BLUETOOTH_LE_BASE + 0x0016;
    public const Int32 WCL_E_BLUETOOTH_LE_RELIABLE_WRITE_ACTIVE = WCL_E_BLUETOOTH_LE_BASE + 0x0017;
    public const Int32 WCL_E_BLUETOOTH_LE_RELIABLE_WRITE_NOT_ACTIVE = WCL_E_BLUETOOTH_LE_BASE + 0x0018;
    public const Int32 WCL_E_BLUETOOTH_LE_ALREADY_SUBSCRIBED = WCL_E_BLUETOOTH_LE_BASE + 0x0019;
    public const Int32 WCL_E_BLUETOOTH_LE_NOT_SUBSCRIBED = WCL_E_BLUETOOTH_LE_BASE + 0x001A;
    public const Int32 WCL_E_BLUETOOTH_LE_DEVICES_SCANNING_ENABLED = WCL_E_BLUETOOTH_LE_BASE + 0x001B;
    public const Int32 WCL_E_BLUETOOTH_LE_DEVICES_SCANNING_DISABLED = WCL_E_BLUETOOTH_LE_BASE + 0x001C;
    public const Int32 WCL_E_BLUETOOTH_LE_INAVLID_USER_BUFFER = WCL_E_BLUETOOTH_LE_BASE + 0x001D;
    public const Int32 WCL_E_BLUETOOTH_LE_INCONSISTENT_DATA = WCL_E_BLUETOOTH_LE_BASE + 0x001E;
    public const Int32 WCL_E_BLUETOOTH_LE_COMMUNICATION_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x001F;
    public const Int32 WCL_E_BLUETOOTH_LE_CHARACTERISTIC_NOT_READABLE = WCL_E_BLUETOOTH_LE_BASE + 0x0020;
    public const Int32 WCL_E_BLUETOOTH_LE_CREATE_WATCHER_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0021;
    public const Int32 WCL_E_BLUETOOTH_LE_SET_SCANNING_MODE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0022;
    public const Int32 WCL_E_BLUETOOTH_LE_START_WATCHER_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0023;
    public const Int32 WCL_E_BLUETOOTH_LE_START_WINRT_THREAD_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0024;
    public const Int32 WCL_E_BLUETOOTH_LE_SET_EVENT_HANDLER_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0025;
    public const Int32 WCL_E_BLUETOOTH_LE_CREATE_DEVICE_STATICS_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0026;
    public const Int32 WCL_E_BLUETOOTH_LE_CREATE_DEVICE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0027;
    public const Int32 WCL_E_BLUETOOTH_LE_START_ASYNC_OPERATION_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0028;
    public const Int32 WCL_E_BLUETOOTH_LE_SET_ASYNC_OPERATION_EVENT_HANDLER_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0029;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_ASYNC_OPERATION_RESULT_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x002A;
    public const Int32 WCL_E_BLUETOOTH_LE_CREATE_DEVICE2_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x002B;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_INFORMATION_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x002C;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_INFORMATION2_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x002D;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_INFORMATION_PAIRING_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x002E;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_INFORMATION_PAIRING2_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x002F;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_INFORMATION_CUSTOM_PAIRING_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0030;
    public const Int32 WCL_E_BLUETOOTH_LE_BEACON_MONITORING_RUNNING = WCL_E_BLUETOOTH_LE_BASE + 0x0031;
    public const Int32 WCL_E_BLUETOOTH_LE_BEACON_MONITORING_NOT_RUNNING = WCL_E_BLUETOOTH_LE_BASE + 0x0032;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_RUNNING = WCL_E_BLUETOOTH_LE_BASE + 0x0033;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_NOT_RUNNING = WCL_E_BLUETOOTH_LE_BASE + 0x0034;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_UNBALE_CREATE_INIT_EVENT = WCL_E_BLUETOOTH_LE_BASE + 0x0035;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_UNBALE_CREATE_TERMINATE_EVENT = WCL_E_BLUETOOTH_LE_BASE + 0x0036;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_UNBALE_START_THREAD = WCL_E_BLUETOOTH_LE_BASE + 0x0037;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_START_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0038;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_GET_ADVERTISER = WCL_E_BLUETOOTH_LE_BASE + 0x0039;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_GET_ADVERTISER_MANUFACTURER_DATA = WCL_E_BLUETOOTH_LE_BASE + 0x003A;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_SET_ADVERTISING_DATA = WCL_E_BLUETOOTH_LE_BASE + 0x003B;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_ADD_ADVERTISING_DATA = WCL_E_BLUETOOTH_LE_BASE + 0x003C;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_GET_ADVERTISER_DATA = WCL_E_BLUETOOTH_LE_BASE + 0x003D;
    public const Int32 WCL_E_BLUETOOTH_LE_EDDYSTONE_URL_TOO_SHORT = WCL_E_BLUETOOTH_LE_BASE + 0x003E;
    public const Int32 WCL_E_BLUETOOTH_LE_EDDYSTONE_URL_SCHEME_INVALID = WCL_E_BLUETOOTH_LE_BASE + 0x003F;
    public const Int32 WCL_E_BLUETOOTH_LE_EDDYSTONE_URL_TOO_LONG = WCL_E_BLUETOOTH_LE_BASE + 0x0040;
    public const Int32 WCL_E_BLUETOOTH_LE_ASYNC_PAIR_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0041;
    public const Int32 WCL_E_BLUETOOTH_LE_ASYNC_PAIR_ERROR = WCL_E_BLUETOOTH_LE_BASE + 0x0042;
    public const Int32 WCL_E_BLUETOOTH_LE_MANUAL_PAIRING_REQUIRED = WCL_E_BLUETOOTH_LE_BASE + 0x0043;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_NOT_READY_TO_PAIR = WCL_E_BLUETOOTH_LE_BASE + 0x0044;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_NOT_PAIRED = WCL_E_BLUETOOTH_LE_BASE + 0x0045;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_CONNECTION_REJECTED = WCL_E_BLUETOOTH_LE_BASE + 0x0046;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_TOO_MANY_CONNECTIONS = WCL_E_BLUETOOTH_LE_BASE + 0x0047;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_HARDWARE_FAILURE = WCL_E_BLUETOOTH_LE_BASE + 0x0048;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_TIMEOUT = WCL_E_BLUETOOTH_LE_BASE + 0x0049;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_NOT_ALLOWED = WCL_E_BLUETOOTH_LE_BASE + 0x004A;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_FAILURE = WCL_E_BLUETOOTH_LE_BASE + 0x004B;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_NO_SUPPORTED_PROFILE = WCL_E_BLUETOOTH_LE_BASE + 0x004C;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_PROTECTION_LEVEL_COULD_NOT_BE_MET = WCL_E_BLUETOOTH_LE_BASE + 0x004D;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_ACCESS_DENIED = WCL_E_BLUETOOTH_LE_BASE + 0x004E;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_INVALID_CEREMONY_DATA = WCL_E_BLUETOOTH_LE_BASE + 0x004F;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_PAIRING_CANCELED = WCL_E_BLUETOOTH_LE_BASE + 0x0050;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_OPERATION_ALREADY_IN_POROGRESS = WCL_E_BLUETOOTH_LE_BASE + 0x0051;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_REQUIRED_HANDLER_NOT_REGISTERED = WCL_E_BLUETOOTH_LE_BASE + 0x0052;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_REJECTED_BY_HANDLER = WCL_E_BLUETOOTH_LE_BASE + 0x0053;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_REMOTE_DEVICE_HAS_ASSOCIATION = WCL_E_BLUETOOTH_LE_BASE + 0x0054;
    public const Int32 WCL_E_BLUETOOTH_LE_AUTH_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0055;
    public const Int32 WCL_E_BLUETOOTH_LE_SET_PROTECTION_LEVEL_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0056;
    public const Int32 WCL_E_BLUETOOTH_LE_CHARACTERISTIC_NOT_WRITABLE = WCL_E_BLUETOOTH_LE_BASE + 0x0057;
    public const Int32 WCL_E_BLUETOOTH_LE_DEVICE_NOT_DISCOVERED = WCL_E_BLUETOOTH_LE_BASE + 0x0058;
    public const Int32 WCL_E_BLUETOOTH_LE_ALREADY_PAIRED = WCL_E_BLUETOOTH_LE_BASE + 0x0059;
    public const Int32 WCL_E_BLUETOOTH_LE_UNSUPPORTED_BY_HARDWARE = WCL_E_BLUETOOTH_LE_BASE + 0x005A;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_START_UNPAIRING = WCL_E_BLUETOOTH_LE_BASE + 0x005B;
    public const Int32 WCL_E_BLUETOOTH_LE_DEVICE_NOT_FOUND = WCL_E_BLUETOOTH_LE_BASE + 0x005C;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_ID_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x005D;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DEVICE_PROPERTIES_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x005E;
    public const Int32 WCL_E_BLUETOOTH_LE_FEATURE_NOT_SUPPORTED = WCL_E_BLUETOOTH_LE_BASE + 0x005F;
    public const Int32 WCL_E_BLUETOOTH_LE_UNABLE_READ_RSSI = WCL_E_BLUETOOTH_LE_BASE + 0x0060;
    public const Int32 WCL_E_BLUETOOTH_LE_START_RSSI_THREAD_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0061;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_RSSI_READING_RESULT_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0062;
    public const Int32 WCL_E_BLUETOOTH_LE_ADVERTISING_SET_NAME_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0063;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_OPERATION_RESULT_FAULED = WCL_E_BLUETOOTH_LE_BASE + 0x0064;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_ROOT_SERVICE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0065;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_SERVICE_HANDLE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0066;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISTIC_HANDLE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0067;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTOR_HANDLE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0068;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTOR_UUID_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0069;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMATS_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x006A;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMATS_LIST_SIZE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x006B;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMAT_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x006C;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMAT_TYPE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x006D;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMAT_EXPONENT_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x006E;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMAT_UNIT_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x006F;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMAT_NAMESPACE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0070;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_PRESENTATION_FORMAT_DESCRIPTION_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0071;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTOR_VALUE_SIZE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0072;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTOR_VALUE_RAW_DATA_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0073;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTOR_VALUE_DATA_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0074;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISTIC_UUID_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0075;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISTIC_PROPETIES_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0076;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTOR_VALUE_DATA_BUFFER_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0077;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISTIC_VALUE_DATA_BUFFER_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0078;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISTIC_VALUE_SIZE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x0079;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISITC_VALUE_RAW_DATA_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x007A;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISITC_VALUE_DATA_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x007B;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_DESCRIPTORS_LIST_SIZE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x007C;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_SERVICE_UUID_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x007D;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_CHARACTERISITCS_LIST_SIZE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x007E;
    public const Int32 WCL_E_BLUETOOTH_LE_GET_SERVICES_LIST_SIZE_FAILED = WCL_E_BLUETOOTH_LE_BASE + 0x007F;
};

// The base class for Bluetooth Framework C++ Edition wrappers.
// It must be disposable.
public abstract class BluetoothImports : IDisposable
{
    private Boolean FDisposed;

    private void Dispose(Boolean Disposing)
    {
        if (FDisposed)
            return;

        Free();

        FDisposed = true;
    }

    // This can be overridden. Called when object is disposing.
    protected virtual void Free()
    {

    }

    protected Boolean Disposed { get { return FDisposed; } }

    protected internal const String RfCommClientDllName = "..\\WclRfCommClientDll\\build\\WclRfCommClientDll.dll";

    public BluetoothImports()
    {
        FDisposed = false;
    }

    ~BluetoothImports()
    {
        Dispose(false);
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
};

#region Bluetooth Manager delegates
public delegate void DeviceFoundEvent(System.Object sender, IntPtr Radio, Int64 Address);
public delegate void DiscoveringStartedEvent(System.Object sender, IntPtr Radio);
public delegate void DiscoveringCompletedEvent(System.Object sender, IntPtr Radio, Int32 Error);
public delegate void NumericComparisonEvent(System.Object sender, IntPtr Radio, Int64 Address,
    UInt32 Number, out Boolean Confirm);
public delegate void PasskeyNotificationEvent(System.Object sender, IntPtr Radio, Int64 Address,
    Int64 Passkey);
public delegate void PasskeyRequestEvent(System.Object sender, IntPtr Radio, Int64 Address,
    out UInt32 Passkey);
public delegate void PinRequestEvent(System.Object sender, IntPtr Radio, Int64 Address,
    out String Pin);
public delegate void AuthenticationCompletedEvent(System.Object sender, IntPtr Radio, Int64 Address,
    Int32 Error);
#endregion

public class BluetoothManager : BluetoothImports
{
    #region Bluetooth Manager callback types
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void NOTIFY_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void DEVICE_FOUND_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Address);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void DISCOVERING_STARTED_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void DISCOVERING_COMPLETED_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I4), In] Int32 Error);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void NUMERIC_COMPARISON_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Address,
        [param: MarshalAs(UnmanagedType.U4), In] UInt32 Number);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void PASSKEY_NOTIFICATION_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Address,
        [param: MarshalAs(UnmanagedType.U4), In] Int64 Passkey);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void PASSKEY_REQUEST_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Address);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void PIN_REQUEST_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Address);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void AUTHENTICATION_COMPLETED_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Address,
        [param: MarshalAs(UnmanagedType.I4), In] Int32 Error);
    #endregion

    #region Bluetooth Manager imports
    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.SysInt)]
    private static extern IntPtr ManagerCreate();

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerDestroy(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 ManagerOpen(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 ManagerClose(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 ManagerGetRadioCount(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.SysInt)]
    private static extern IntPtr ManagerGetRadio(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.I4)] Int32 Index);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetAfterOpen(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] NOTIFY_EVENT Event);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetBeforeClose(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] NOTIFY_EVENT Event);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetOnDeviceFound(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] DEVICE_FOUND_EVENT Event);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetOnDiscoveringStarted(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] DISCOVERING_STARTED_EVENT Event);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetOnDiscoveringCompleted(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] DISCOVERING_COMPLETED_EVENT Event);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetOnNumericComparison(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] NUMERIC_COMPARISON_EVENT Event);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetOnPasskeyNotification(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] PASSKEY_NOTIFICATION_EVENT Event);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetOnPasskeyRequest(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] PASSKEY_REQUEST_EVENT Event);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetOnPinRequest(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] PIN_REQUEST_EVENT Event);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetOnAuthenticationCompleted(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] AUTHENTICATION_COMPLETED_EVENT Event);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetConfirm(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.Bool), In] Boolean Confirm);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetPasskey(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.U4), In] UInt32 Passkey);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ManagerSetPin(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Manager,
        [param: MarshalAs(UnmanagedType.LPTStr), In] String Pin);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioDiscover(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.U4), In] UInt32 Timeout);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioTerminate(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern Boolean RadioIsAvailable(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioGetDeviceName(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Address,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Name,
        [param: MarshalAs(UnmanagedType.I4), In] Int32 Len);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioPair(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Address);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioUnpair(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Address);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioEnumPaired(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.U4), In, Out] ref UInt32 Size,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Addresses);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioGetConnectable(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.Bool), Out] out Boolean Connectable);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioGetDiscoverable(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.Bool), Out] out Boolean Discoverable);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioSetConnectable(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.Bool), In] Boolean Connectable);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioSetDiscoverable(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio,
        [param: MarshalAs(UnmanagedType.Bool), In] Boolean Discoverable);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioTurnOn(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 RadioTurnOff(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio);
    #endregion

    // Bluetooth Manager instance.
    private IntPtr FManager;

    #region Bluetooth Manager callback delegates
    private NOTIFY_EVENT FAfterOpen;
    private NOTIFY_EVENT FBeforeClose;
    private DEVICE_FOUND_EVENT FOnDeviceFound;
    private DISCOVERING_STARTED_EVENT FOnDiscoveringStarted;
    private DISCOVERING_COMPLETED_EVENT FOnDiscoveringCompleted;
    private NUMERIC_COMPARISON_EVENT FOnNumericComparison;
    private PASSKEY_NOTIFICATION_EVENT FOnPasskeyNotification;
    private PASSKEY_REQUEST_EVENT FOnPasskeyRequest;
    private PIN_REQUEST_EVENT FOnPinRequest;
    private AUTHENTICATION_COMPLETED_EVENT FOnAuthenticationCompleted;
    #endregion

    #region Bluetooth Manager callback handlers
    private void DoAfterOpen(IntPtr sender)
    {
        if (AfterOpen != null)
            AfterOpen(this, EventArgs.Empty);
    }

    private void DoBeofreClose(IntPtr sender)
    {
        if (BeforeClose != null)
            BeforeClose(this, EventArgs.Empty);
    }

    private void DoDeviceFound(IntPtr sender, IntPtr Radio, Int64 Address)
    {
        if (OnDeviceFound != null)
            OnDeviceFound(this, Radio, Address);
    }

    private void DoDiscoveringStarted(IntPtr sender, IntPtr Radio)
    {
        if (OnDiscoveringStarted != null)
            OnDiscoveringStarted(this, Radio);
    }

    private void DoDiscoveringCompleted(IntPtr sender, IntPtr Radio, Int32 Error)
    {
        if (OnDiscoveringCompleted != null)
            OnDiscoveringCompleted(this, Radio, Error);
    }

    private void DoNumericComparison(IntPtr sender, IntPtr Radio, Int64 Address, UInt32 Number)
    {
        Boolean Confirm = false;
        if (OnNumericComparison != null)
            OnNumericComparison(this, Radio, Address, Number, out Confirm);
        ManagerSetConfirm(sender, Confirm);
    }

    private void DoPasskeyNotification(IntPtr sender, IntPtr Radio, Int64 Address, Int64 Passkey)
    {
        if (OnPasskeyNotification != null)
            OnPasskeyNotification(this, Radio, Address, Passkey);
    }

    private void DoPasskeyRequest(IntPtr sender, IntPtr Radio, Int64 Address)
    {
        UInt32 Passkey = 0;
        if (OnPasskeyRequest != null)
            OnPasskeyRequest(this, Radio, Address, out Passkey);
        ManagerSetPasskey(sender, Passkey);
    }

    private void DoPinRequest(IntPtr sender, IntPtr Radio, Int64 Address)
    {
        String Pin = "";
        if (OnPinRequest != null)
            OnPinRequest(this, Radio, Address, out Pin);
        ManagerSetPin(sender, Pin);
    }

    private void DoAuthenticationCompleted(IntPtr sender, IntPtr Radio, Int64 Address, Int32 Error)
    {
        if (OnAuthenticationCompleted != null)
            OnAuthenticationCompleted(this, Radio, Address, Error);
    }
    #endregion

    protected override void Free()
    {
        // Call close first if we did not do it yet.
        Close();

        // Cleanup callbacks.
        ManagerSetAfterOpen(FManager, null);
        ManagerSetBeforeClose(FManager, null);
        ManagerSetOnAuthenticationCompleted(FManager, null);
        ManagerSetOnDeviceFound(FManager, null);
        ManagerSetOnDiscoveringCompleted(FManager, null);
        ManagerSetOnDiscoveringStarted(FManager, null);
        ManagerSetOnNumericComparison(FManager, null);
        ManagerSetOnPasskeyNotification(FManager, null);
        ManagerSetOnPasskeyRequest(FManager, null);
        ManagerSetOnPinRequest(FManager, null);

        // Dispose delegates.
        FAfterOpen = null;
        FBeforeClose = null;
        FOnDeviceFound = null;
        FOnDiscoveringStarted = null;
        FOnDiscoveringCompleted = null;
        FOnNumericComparison = null;
        FOnPasskeyNotification = null;
        FOnPasskeyRequest = null;
        FOnPinRequest = null;
        FOnAuthenticationCompleted = null;

        // Delete Bluetooth Manager instance.
        ManagerDestroy(FManager);

        // And that's all
        FManager = IntPtr.Zero;
    }

    public BluetoothManager()
        : base()
    {
        AfterOpen = null;
        BeforeClose = null;
        OnDeviceFound = null;
        OnDiscoveringStarted = null;
        OnDiscoveringCompleted = null;
        OnNumericComparison = null;
        OnPasskeyNotification = null;
        OnPasskeyRequest = null;
        OnPinRequest = null;
        OnAuthenticationCompleted = null;

        // Initialize callback delegates with its handlers.
        FAfterOpen = new NOTIFY_EVENT(DoAfterOpen);
        FBeforeClose = new NOTIFY_EVENT(DoBeofreClose);
        FOnAuthenticationCompleted = new AUTHENTICATION_COMPLETED_EVENT(DoAuthenticationCompleted);
        FOnDeviceFound = new DEVICE_FOUND_EVENT(DoDeviceFound);
        FOnDiscoveringCompleted = new DISCOVERING_COMPLETED_EVENT(DoDiscoveringCompleted);
        FOnDiscoveringStarted = new DISCOVERING_STARTED_EVENT(DoDiscoveringStarted);
        FOnNumericComparison = new NUMERIC_COMPARISON_EVENT(DoNumericComparison);
        FOnPasskeyNotification = new PASSKEY_NOTIFICATION_EVENT(DoPasskeyNotification);
        FOnPasskeyRequest = new PASSKEY_REQUEST_EVENT(DoPasskeyRequest);
        FOnPinRequest = new PIN_REQUEST_EVENT(DoPinRequest);

        // Create Bluetooth Manager instance...
        FManager = ManagerCreate();
        // ...and setup callbacks.
        ManagerSetAfterOpen(FManager, FAfterOpen);
        ManagerSetBeforeClose(FManager, FBeforeClose);
        ManagerSetOnAuthenticationCompleted(FManager, FOnAuthenticationCompleted);
        ManagerSetOnDeviceFound(FManager, FOnDeviceFound);
        ManagerSetOnDiscoveringCompleted(FManager, FOnDiscoveringCompleted);
        ManagerSetOnDiscoveringStarted(FManager, FOnDiscoveringStarted);
        ManagerSetOnNumericComparison(FManager, FOnNumericComparison);
        ManagerSetOnPasskeyNotification(FManager, FOnPasskeyNotification);
        ManagerSetOnPasskeyRequest(FManager, FOnPasskeyRequest);
        ManagerSetOnPinRequest(FManager, FOnPinRequest);
    }

    #region Bluetooth Manager methods
    public Int32 Open()
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return ManagerOpen(FManager);
    }

    public Int32 Close()
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return ManagerClose(FManager);
    }

    public Int32 Discover(IntPtr Radio, UInt32 Timeout)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioDiscover(Radio, Timeout);
    }

    public Int32 Terminate(IntPtr Radio)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioTerminate(Radio);
    }

    public Boolean IsRadioAvailable(IntPtr Radio)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioIsAvailable(Radio);
    }

    public Int32 GetRemoteName(IntPtr Radio, Int64 Address, out String Name)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        Name = "";

        // Bluetooth device's name can not be longer that 128 chars. To be 100% sure we will use 256 chars
        // memory block.
        IntPtr pName;
        Int32 Result;

        pName = Marshal.AllocHGlobal(256 * sizeof(Char));
        try
        {
            Result = RadioGetDeviceName(Radio, Address, pName, 256);
            if (Result == BluetoothErrors.WCL_E_SUCCESS)
                Name = Marshal.PtrToStringUni(pName);
        }
        finally
        {
            Marshal.FreeHGlobal(pName);
        }

        return Result;
    }

    public Int32 Pair(IntPtr Radio, Int64 Address)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioPair(Radio, Address);
    }

    public Int32 Unpair(IntPtr Radio, Int64 Address)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioUnpair(Radio, Address);
    }

    public Int32 EnumPaired(IntPtr Radio, out Int64[] Devices)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        Devices = null;
        UInt32 Size = 0;
        Int32 Res = RadioEnumPaired(Radio, ref Size, IntPtr.Zero);
        if (Res == BluetoothErrors.WCL_E_SUCCESS && Size > 0)
        {
            IntPtr pDevices = Marshal.AllocHGlobal((int)Size * sizeof(Int64));
            try
            {
                Res = RadioEnumPaired(Radio, ref Size, pDevices);
                if (Res == BluetoothErrors.WCL_E_SUCCESS)
                {
                    Devices = new Int64[Size];
                    for (UInt32 i = 0; i < Size; i++)
                        Devices[i] = Marshal.ReadInt64(pDevices, (int)i * sizeof(Int64));
                }
            }
            finally
            {
                Marshal.FreeHGlobal(pDevices);
            }
        }
        return Res;
    }

    public Int32 GetConnectable(IntPtr Radio, out Boolean Connectable)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioGetConnectable(Radio, out Connectable);
    }

    public Int32 GetDiscoverable(IntPtr Radio, out Boolean Discoverable)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioGetDiscoverable(Radio, out Discoverable);
    }

    public Int32 SetConnectable(IntPtr Radio, Boolean Connectable)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioSetConnectable(Radio, Connectable);
    }

    public Int32 SetDiscoverable(IntPtr Radio, Boolean Discoverable)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioSetDiscoverable(Radio, Discoverable);
    }

    public Int32 TurnOn(IntPtr Radio)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioTurnOn(Radio);
    }

    public Int32 TurnOff(IntPtr Radio)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return RadioTurnOff(Radio);
    }
    #endregion

    #region Bluetooth Manager properties
    public Int32 Count
    {
        get
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            return ManagerGetRadioCount(FManager);
        }
    }

    public IntPtr this[Int32 Index]
    {
        get
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            return ManagerGetRadio(FManager, Index);
        }
    }
    #endregion

    #region Bluetooth Manager events
    public event EventHandler AfterOpen;
    public event EventHandler BeforeClose;
    public event DeviceFoundEvent OnDeviceFound;
    public event DiscoveringStartedEvent OnDiscoveringStarted;
    public event DiscoveringCompletedEvent OnDiscoveringCompleted;
    public event NumericComparisonEvent OnNumericComparison;
    public event PasskeyNotificationEvent OnPasskeyNotification;
    public event PasskeyRequestEvent OnPasskeyRequest;
    public event PinRequestEvent OnPinRequest;
    public event AuthenticationCompletedEvent OnAuthenticationCompleted;
    #endregion
};

#region RfComm Client event delegates
public delegate void ConnectEvent(System.Object Sender, Int32 Error);
public delegate void DisconnectEvent(System.Object Sender, Int32 Reason);
public delegate void DataEvent(System.Object Sender, Byte[] Data);
#endregion

public class RfCommClient : BluetoothImports
{
    #region RfComm Client callback types
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void CLIENT_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.I4), In] Int32 Error);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void DATA_EVENT(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr sender,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Data,
        [param: MarshalAs(UnmanagedType.U4), In] UInt32 Size);
    #endregion

    #region RfComm Client imports
    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.SysInt)]
    private static extern IntPtr ClientCreate();

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ClientDestroy(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ClientSetOnConnect(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] CLIENT_EVENT Event);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ClientSetOnDisconnect(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] CLIENT_EVENT Event);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ClientSetOnData(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.FunctionPtr), In] DATA_EVENT Event);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 ClientConnect(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Radio);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 ClientDisconnect(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 ClientGetReadBufferSize(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.U4), Out] out UInt32 Size);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 ClientGetWriteBufferSize(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.U4), Out] out UInt32 Size);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 ClientSetReadBufferSize(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client, 
        [param: MarshalAs(UnmanagedType.U4), In] UInt32 Size);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 ClientSetWriteBufferSize(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client, 
        [param: MarshalAs(UnmanagedType.U4), In] UInt32 Size);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I4)]
    private static extern Int32 ClientWrite(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.SysInt)] IntPtr Data, 
        [param: MarshalAs(UnmanagedType.U4)] UInt32 Size,
        [param: MarshalAs(UnmanagedType.U4), Out] out UInt32 Written);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.SysInt)]
    private static extern IntPtr ClientGetRadio(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern Guid ClientGetService(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ClientSetService(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: In] Guid Value);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern Boolean ClientGetConnected(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.I8)]
    private static extern Int64 ClientGetAddress(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ClientSetAddress(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.I8), In] Int64 Value);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern Boolean ClientGetAuthentication(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ClientSetAuthentication(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client, 
        [param: MarshalAs(UnmanagedType.Bool), In] Boolean Value);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.U1)]
    private static extern Byte ClientGetChannel(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ClientSetChannel(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.U1), In] Byte Value);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern Boolean ClientGetEncryption(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ClientSetEncryption(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.Bool), In] Boolean Value);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    [return: MarshalAs(UnmanagedType.U4)]
    private static extern UInt32 ClientGetTimeout(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client);

    [DllImport(RfCommClientDllName, CallingConvention = CallingConvention.StdCall)]
    private static extern void ClientSetTimeout(
        [param: MarshalAs(UnmanagedType.SysInt), In] IntPtr Client,
        [param: MarshalAs(UnmanagedType.U4), In] UInt32 Value);
    #endregion

    // RfComm Client instance.
    private IntPtr FClient;

    #region RfComm Client callback delegates
    private CLIENT_EVENT FOnConnect;
    private CLIENT_EVENT FOnDisconnect;
    private DATA_EVENT FOnData;
    #endregion

    #region RfComm Client callback handlers
    private void DoConnect(IntPtr Sender, Int32 Error)
    {
        if (OnConnect != null)
            OnConnect(this, Error);
    }

    private void DoDisconnect(IntPtr Sender, Int32 Error)
    {
        if (OnDisconnect != null)
            OnDisconnect(this, Error);
    }

    private void DoData(IntPtr Sender, IntPtr Data, UInt32 Size)
    {
        if (Data != IntPtr.Zero && Size > 0 && OnData != null)
        {
            Byte[] data = new Byte[Size];
            Marshal.Copy(Data, data, 0, (Int32)Size);
            OnData(this, data);
            data = null;
        }
    }
    #endregion

    protected override void Free()
    {
        Disconnect();

        // Cleanup callbacks.
        ClientSetOnConnect(FClient, null);
        ClientSetOnDisconnect(FClient, null);
        ClientSetOnData(FClient, null);

        // Dispose delegates.
        FOnConnect = null;
        FOnDisconnect = null;
        FOnData = null;

        // Destroy RfComm Client instance.
        ClientDestroy(FClient);
        FClient = IntPtr.Zero;
    }

    public RfCommClient()
        : base()
    {
        OnConnect = null;
        OnDisconnect = null;
        OnData = null;

        // Initialize delegates
        FOnConnect = new CLIENT_EVENT(DoConnect);
        FOnDisconnect = new CLIENT_EVENT(DoDisconnect);
        FOnData = new DATA_EVENT(DoData);

        // Create RfComm Client instance.
        FClient = ClientCreate();        

        // And setup callbacks.
        ClientSetOnConnect(FClient, FOnConnect);
        ClientSetOnDisconnect(FClient, FOnDisconnect);
        ClientSetOnData(FClient, FOnData);
    }

    #region RfComm Client methods
    public Int32 Connect(IntPtr Radio)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return ClientConnect(FClient, Radio);
    }

    public Int32 Disconnect()
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return ClientDisconnect(FClient);
    }

    public Int32 GetReadBufferSize(out UInt32 Size)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return ClientGetReadBufferSize(FClient, out Size);
    }

    public Int32 GetWriteBufferSize(out UInt32 Size)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return ClientGetWriteBufferSize(FClient, out Size);
    }

    public Int32 SetReadBufferSize(UInt32 Size)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return ClientSetReadBufferSize(FClient, Size);
    }

    public Int32 SetWriteBufferSize(UInt32 Size)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        return ClientSetWriteBufferSize(FClient, Size);
    }

    public Int32 Write(Byte[] Data, out UInt32 Written)
    {
        if (Disposed)
            throw new ObjectDisposedException(this.ToString());

        Written = 0;

        if (Data == null)
            return BluetoothErrors.WCL_E_INVALID_ARGUMENT;

        IntPtr data = Marshal.AllocHGlobal(Data.Length);
        try
        {
            Marshal.Copy(Data, 0, data, Data.Length);
            return ClientWrite(FClient, data, (UInt32)Data.Length, out Written);
        }
        finally
        {
            Marshal.FreeHGlobal(data);
        }
    }
    #endregion

    #region RfComm Client properties
    public IntPtr Radio
    {
        get
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            return ClientGetRadio(FClient);
        }
    }

    public Guid Service
    {
        get
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            return ClientGetService(FClient);
        }

        set
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            ClientSetService(FClient, value);
        }
    }

    public Boolean Connected
    {
        get
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            return ClientGetConnected(FClient);
        }
    }

    public Int64 Address
    {
        get
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            return ClientGetAddress(FClient);
        }

        set
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            ClientSetAddress(FClient, value);
        }
    }

    public Boolean Authentication
    {
        get
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            return ClientGetAuthentication(FClient);
        }

        set
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            ClientSetAuthentication(FClient, value);
        }
    }

    public Byte Channel
    {
        get
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            return ClientGetChannel(FClient);
        }

        set
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            ClientSetChannel(FClient, value);
        }
    }

    public Boolean Encryption
    {
        get
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            return ClientGetEncryption(FClient);
        }

        set
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            ClientSetEncryption(FClient, value);
        }
    }

    public UInt32 Timeout
    {
        get
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            return ClientGetTimeout(FClient);
        }

        set
        {
            if (Disposed)
                throw new ObjectDisposedException(this.ToString());

            ClientSetTimeout(FClient, value);
        }
    }
    #endregion

    #region RfComm Client events
    public event ConnectEvent OnConnect;
    public event DisconnectEvent OnDisconnect;
    public event DataEvent OnData;
    #endregion
};

public class RfCommClientWrapper : MonoBehaviour
{
    private BluetoothManager FManager = null;
    private RfCommClient FClient = null;
    private List<Int64> FDevices = null; // List used during discovering.
    private Boolean FFirstAttempt = false; // Used during connection.

    #region Some helper methods
    // Returns TRUE if device was found. FALSE otherwise. It allows us to rediscover device if it was not found.
    private Boolean TryToConnect(IntPtr Radio)
    {
        Boolean Found = false;

        // The code moved from OnDiscoveringCompleted event handler.
        if (FDevices.Count == 0)
            Debug.Log("No one Bluetooth device were found");
        else
        {
            // Look for our device.
            foreach (Int64 Address in FDevices)
            {
                if (Address == 0xB48655ED4B8C) // Change this address to your device's MAC
                {
                    Found = true;

                    // Here we can try to connect to our device.

                    // By default RfCommClient uses SPP. To change it set the Service property to the required service's UUID.
                    //FClient.Service = < YOUR_UUID >;

                    // You can also disable authentication if your device does not need it.
                    //FClient.Authentication = false;

                    // Set the device's address. Note, that if client is already connected this raises an exception.
                    // However in our example we are sure that client is not connected so it is safe to ignore any exceptions.
                    FClient.Address = Address;
                    // Indicate that this is our first attempt to connect.
                    FFirstAttempt = true;

                    // Now try to connect. Use the same radio we used to discovering.
                    Int32 Res = FClient.Connect(Radio);
                    if (Res != BluetoothErrors.WCL_E_SUCCESS)
                        Debug.Log("Failed to connect: 0x" + Res.ToString("X8"));
                }
            }

            if (!Found)
                Debug.Log("Required device has not been found");
        }

        return Found;
    }
    #endregion
    
    #region Discovering event handlers
    private void FManager_OnDiscoveringStarted(object sender, IntPtr Radio)
    {
        FDevices = new List<Int64>(); // Create found devices list.
        Debug.Log("Discovering has been started");
    }

    private void FManager_OnDeviceFound(object sender, IntPtr Radio, long Address)
    {
        Debug.Log("Device found: " + Address.ToString("X12"));
        // Add device into found devices list.
        FDevices.Add(Address);
    }

    private void FManager_OnDiscoveringCompleted(object sender, IntPtr Radio, int Error)
    {
        Debug.Log("Discovering has been completed with result: 0x" + Error.ToString("X8"));
        try
        {
            // Continue only if discovering completed with success. In real application we must analyze the result
            if (Error == BluetoothErrors.WCL_E_SUCCESS)
            {
                // Move all connection code to separate rountine so it can be used from different discovering methods.
                TryToConnect(Radio);
            }
        }
        finally
        {
            // Do not forget to clear the list.
            FDevices.Clear();
            FDevices = null;
        }
    }
    #endregion

    #region Authentication (pairing) event handlers
    private void FManager_OnPinRequest(object sender, IntPtr Radio, long Address, out string Pin)
    {
        Debug.Log("Device " + Address.ToString("X12") + " requires legacy PIN pairing. Use default: 0000");
        Pin = "0000";
    }

    private void FManager_OnPasskeyRequest(object sender, IntPtr Radio, long Address, out uint Passkey)
    {
        Debug.Log("Device " + Address.ToString("X12") + " requires passkey providing. We use default: 0");
        Passkey = 0;
    }

    private void FManager_OnPasskeyNotification(object sender, IntPtr Radio, long Address, long Passkey)
    {
        Debug.Log("Device " + Address.ToString("X12") + " requires Passkey entering. Passkey: " + Passkey.ToString());
    }

    private void FManager_OnNumericComparison(object sender, IntPtr Radio, long Address, uint Number, out bool Confirm)
    {
        Debug.Log("Device " + Address.ToString("X12") + " requires numeric comparison. Number: " + Number.ToString() + ". Accept it");
        Confirm = true;
    }

    private void FManager_OnAuthenticationCompleted(object sender, IntPtr Radio, long Address, int Error)
    {
        Debug.Log("Authentication with device " + Address.ToString("X12") + " has completed with result: 0x" +
            Error.ToString("X8"));
    }
    #endregion

    #region Common Bluetooth Manager event handlers
    private void FManager_BeforeClose(object sender, EventArgs e)
    {
        Debug.Log("Bluetooth Manager has been closed");
    }

    private void FManager_AfterOpen(object sender, EventArgs e)
    {
        Debug.Log("Bluetooth manager has been opened");

        // Look for working radio.
        if (FManager.Count == 0)
            Debug.Log("No Bluetooth Radios were found");
        else
        {
            IntPtr Radio = IntPtr.Zero;
            for (Int32 i = 0; i < FManager.Count; i++)
            {
                if (FManager.IsRadioAvailable(FManager[i]))
                {
                    Radio = FManager[i];
                    break;
                }
            }

            if (Radio == IntPtr.Zero)
                Debug.Log("No available Bluetooth Radio was found");
            else
            {
                // First try to enumerate paired devices. Probably the device has already been paired and we
                // do not need to discover it.
                Debug.Log("Enum paired devices");
                Int64[] Devices;
                Int32 Res = FManager.EnumPaired(Radio, out Devices);
                Boolean Found = false;
                if (Res == BluetoothErrors.WCL_E_SUCCESS && Devices != null && Devices.Length > 0)
                {
                    // Copy devices into the list because it is used in TryToConnect function.
                    FDevices = new List<Int64>();
                    foreach (Int64 Address in Devices)
                        FDevices.Add(Address);
                    Debug.Log("Try to connect to paired devices");
                    Found = TryToConnect(Radio); // The method clears the List!
                }
                else
                    Debug.Log("Not paired devices found: 0x" + Res.ToString("X8"));
                // And if the device was not found in the paired devices list we try to discover it
                if (!Found)
                {
                    // Here we can start discovering for device.
                    Res = FManager.Discover(Radio, 10); // 10 seconds timeout.
                    if (Res != BluetoothErrors.WCL_E_SUCCESS) // !WCL_E_SUCCESS
                        Debug.Log("Failed to start discovering: 0x" + Res.ToString("X8"));
                }
            }
        }
    }
    #endregion

    #region RfComm Client event handlers
    private void FClient_OnData(object Sender, byte[] Data)
    {
        if (Data != null && Data.Length > 0)
        {
            // I use GPS2Blue app running on my cell and it reports GPS coordinates as string.
            // You have to change this for your needs.
            String Str = System.Text.Encoding.ASCII.GetString(Data);
            Debug.Log(Str);
        }
    }

    private void FClient_OnDisconnect(object Sender, int Reason)
    {
        Debug.Log("Disconnected with reason: 0x" + Reason.ToString("X8"));
    }

    private void FClient_OnConnect(object Sender, int Error)
    {
        Debug.Log("Connected with result: 0x" + Error.ToString("X8"));
        // If connected with error (not connected) check the error code.
        // And if this is WCL_E_BLUETOOTH_LINK_UNEXPECTED then we must try to reconnect.
        if (FFirstAttempt && Error == BluetoothErrors.WCL_E_BLUETOOTH_LINK_UNEXPECTED)
        {
            FFirstAttempt = false; // To prevent from multiple trys to connect.
            // Now we have to unpair device because WCL_E_BLUETOOTH_LINK_UNEXPECTED usually appears when paired
            // devices lost its Link Key.
            Int32 Res = FManager.Unpair(FClient.Radio, FClient.Address);
            if (Res == BluetoothErrors.WCL_E_SUCCESS)
            {
                Debug.Log("Device has been unpaired");
                Debug.Log("Try reconnect");
                Res = FClient.Connect(FClient.Radio);
                if (Res != BluetoothErrors.WCL_E_SUCCESS)
                    Debug.Log("Failed to connect: 0x" + Res.ToString("X8"));
            }
            else
                Debug.Log("Unapir device failed: 0x" + Res.ToString("X8"));
        }
    }
    #endregion

    // Start is called before the first frame update
    void Start()
    {
        // Create RfComm client and setup its events.
        FClient = new RfCommClient();
        FClient.OnConnect += FClient_OnConnect;
        FClient.OnDisconnect += FClient_OnDisconnect;
        FClient.OnData += FClient_OnData;

        // Create Bluetooth Manager and setup its events.
        FManager = new BluetoothManager();
        FManager.AfterOpen += FManager_AfterOpen;
        FManager.BeforeClose += FManager_BeforeClose;
        FManager.OnAuthenticationCompleted += FManager_OnAuthenticationCompleted;
        FManager.OnNumericComparison += FManager_OnNumericComparison;
        FManager.OnPasskeyNotification += FManager_OnPasskeyNotification;
        FManager.OnPasskeyRequest += FManager_OnPasskeyRequest;
        FManager.OnPinRequest += FManager_OnPinRequest;
        FManager.OnDiscoveringStarted += FManager_OnDiscoveringStarted;
        FManager.OnDeviceFound += FManager_OnDeviceFound;
        FManager.OnDiscoveringCompleted += FManager_OnDiscoveringCompleted;

        // Try to open Bluetooth Manager.
        Int32 Res = FManager.Open();
        if (Res != BluetoothErrors.WCL_E_SUCCESS) // !WCL_E_SUCCESS
            Debug.Log("Failed to open Bluetooth Manager: 0x" + Res.ToString("X8"));
    }

    private void OnDestroy()
    {
        // Dispose RfComm Client object. It should also call Disconnect!
        FClient.Dispose();
        // Dispose Bluetooth Manager object, It should also fire BeforeClose
        FManager.Dispose();
    }

    // Update is called once per frame
    void Update()
    {

    }                   
}
